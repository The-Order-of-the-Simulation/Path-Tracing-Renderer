#version 460
#extension GL_ARB_separate_shader_objects : enable

#define WIDTH 1920
#define HEIGHT 1080
#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Pixel {
	vec4 value;
};

layout(std140, binding = 0) buffer buf
{
	Pixel imageData[];
};

// ##### Constants #####

// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/
#define pi 3.141592653589793

// ##### Random Number Generator #####

// Random Number Generator Seed
uint ns;

// Triple32: https://nullprogram.com/blog/2018/07/31/
uint triple32(uint x)
{
	x ^= x >> 17U;
	x *= 0xED5AD4BBU;
	x ^= x >> 11U;
	x *= 0xAC4C1B51U;
	x ^= x >> 15U;
	x *= 0x31848BABU;
	x ^= x >> 14U;
	return x;
}

// Random Number (between 0.0 and 1.0)
float rand()
{
	ns = triple32(ns);
	return float(ns)/float(0xFFFFFFFFU);
}

// Random Vectors
vec2 rand2(){return vec2(rand (), rand());}
vec3 rand3(){return vec3(rand2(), rand());}
vec4 rand4(){return vec4(rand3(), rand());}

// See michael0884's usage of PCG Random
// https://www.shadertoy.com/view/wltcRS
// https://www.shadertoy.com/view/WttyWX

// Normalized Random Vectors
vec2 nrand2(float sigma, vec2 mean)
{
	vec2 z = rand2();
	return mean+sigma*sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y));
}

vec3 nrand3(float sigma, vec3 mean)
{
	vec4 z = rand4();
	return mean+sigma*sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w));
}

vec4 nrand4(float sigma, vec4 mean)
{
	vec4 z = rand4();
	return mean+sigma*sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w));
}

// Uniform Random Direction
vec2 udir2()
{
	float z = 2.0*pi*rand();
	return vec2(sin(z), cos(z));
}

vec3 udir3()
{
	vec2 z = rand2();
	vec2 r = vec2(2.0*pi*z.x, acos(2.0*z.y-1.0));
	vec2 s = sin(r), c = cos(r);
	return vec3(c.x*s.y, s.x*s.y, c.y);
}

// ##### Rendering #####

// Light Transport
vec3 radiance(vec3 ro, vec3 rd)
{
	return rand3();
}

void main()
{
	// OK who made this lmao what the heck
	/*
	In order to fit the work into workgroups, some unnecessary threads are launched.
	We terminate those threads here. 
	*/
	if(gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT)
	{
		return;
	}

	vec2 resolution = vec2(WIDTH, HEIGHT);
	vec2 pixelCoord = vec2(gl_GlobalInvocationID.xy);

	// Initialize Random Number Generator
	ns = uint(gl_GlobalInvocationID.x)+uint(gl_GlobalInvocationID.y)*uint(resolution.x);

	// Image UV Coordinates
	vec2 uv = 2.0*(pixelCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);

	// Set-Up Camera
	const float camfov = 1.0;

	const vec3 ro = vec3(0.0, 0.0, 2.0);
	const mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
	vec3 rd = normalize(vec3(camfov*uv, -1.0)*rotmat);

	// Render the Sample
	vec3 color = radiance(ro, rd);

	// Output the Rendered Sample
	imageData[WIDTH*gl_GlobalInvocationID.y+gl_GlobalInvocationID.x].value = vec4(color, 1.0);
}